<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deine Website</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: #FFFFFF;
            margin: 0;
            padding: 0;
        }

        #container {
            width: 80%;
            margin: 20px auto;
            text-align: center;
        }

        button {
            padding: 10px 20px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            background-color: #434343;
            color: #FFFFFF;
            cursor: pointer;
        }

        button:hover {
            background-color: #555555;
        }

        #canvas-container {
            position: relative;
        }

        canvas {
            display: block;
            margin: 20px auto;
            max-width: 100%;
        }

        #predictions {
            margin-top: 20px;
            list-style-type: none;
            padding: 0;
        }

        input[type="file"] {
            margin: 20px 0;
            color: white;
            background-color: #434343;
        }
    </style>
</head>

<body>
    <div id="container">
        <input type="file" id="fileUpload">
        <button id="classifyBtn">Klassifizieren</button>
        <button id="detectBtn">Objekte erkennen</button>
        <div id="canvas-container">
            <canvas id="imageCanvas"></canvas>
        </div>
        <ul id="predictions"></ul>
    </div>


    <!-- Load TensorFlow.js. This is required to use coco-ssd model. -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"> </script>
    <!-- Load the coco-ssd model. -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"> </script>

    <!-- Load TensorFlow.js. This is required to use MobileNet. -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.1"> </script>
    <!-- Load the MobileNet model. -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@1.0.0"> </script>


    <script>

        let uploadedImage;
        let isImageLoaded = false;

        document.getElementById('imageUpload').addEventListener('change', function (event) {
            const inputElement = event.target;
            if (inputElement.files && inputElement.files[0]) {
                uploadedImage = new Image();
                uploadedImage.onload = function () {
                    isImageLoaded = true; // Setzen Sie den Status auf "geladen", wenn das Bild geladen ist
                };
                uploadedImage.src = URL.createObjectURL(inputElement.files[0]);
            }
        });

        document.getElementById('classifyButton').addEventListener('click', function () {
            if (uploadedImage && isImageLoaded) {
                classifyImage(uploadedImage);
            } else {
                alert("Bitte warten, bis das Bild vollständig geladen ist oder lade zuerst ein Bild hoch");
            }
        });

        function classifyImage(imgElement) {
            // Verwenden Sie das Bild mit TensorFlow.js
            const imageTensor = tf.browser.fromPixels(imgElement);
            // ... Ihr Code zur Klassifizierung des Bildes ...

            /*mobilenet.load().then(model => {
              // Classify the image.
              model.classify(imageTensor).then(predictions => {
                console.log('Predictions: ');
                console.log(predictions);
                displayResults(predictions);
              });
            });*/
            cocoSsd.load().then(model => {
                // detect objects in the image.
                model.detect(imageTensor).then(predictions => {
                    console.log('Predictions: ', predictions);
                    drawBoundingBoxes(imgElement, predictions, window.innerWidth);
                });
            });
        }

        function drawBoundingBoxes(imageElement, detections, maxWidth) {
            const aspectRatio = imageElement.width / imageElement.height;

            const canvasWidth = Math.min(maxWidth, imageElement.width); // Beschränken Sie die Breite auf maxWidth oder die Bildbreite, je nachdem, welcher Wert kleiner ist.
            const canvasHeight = canvasWidth / aspectRatio;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Zeichnen Sie das Bild skaliert auf das Canvas
            ctx.drawImage(imageElement, 0, 0, canvasWidth, canvasHeight);

            detections.forEach(detection => {
                const [x, y, width, height] = detection.bbox.map(val => val * (canvasWidth / imageElement.width));  // Skalieren der Bounding Box gemäß der neuen Canvas-Größe
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 4;
                ctx.strokeRect(x, y, width, height);

                const text = `${detection.class} ${(detection.score * 100).toFixed(1)}%`;
                ctx.fillStyle = 'red';
                ctx.font = '20px Arial';
                ctx.fillText(text, x, y > 20 ? y - 5 : y + 25);
            });

            document.body.appendChild(canvas);
        }

        /*function displayResults(predictions) {
          const resultsDiv = document.getElementById('results');
          let htmlContent = '<ol>';
    
          predictions.forEach(prediction => {
            htmlContent += `
                <li>
                    ${prediction.className}: ${(prediction.probability * 100).toFixed(1)}%
                </li>
            `;
          });
    
          htmlContent += '</ol>';
          resultsDiv.innerHTML = htmlContent;
        }*/

    </script>

</body>

</html>